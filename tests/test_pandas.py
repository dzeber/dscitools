import re

import pytest
from pandas import DataFrame

try:
    from pandas.testing import assert_frame_equal
except ImportError:
    from pandas.util.testing import assert_frame_equal
from numpy import nan as npnan
from IPython.display import display

from dscitools.pandas import FormattedDataFrame, fmt_df, fmt_count_df
from tests.utils import get_notebook_rich_output


BASE_DF = {
    "group": ["a", "b", "c", "d", "e"],
    "num": [10235, 6426, 325, -9453, -1362],
    "prop": [0.02426, 0.3333333, 0.578135, 0.7, 0.25],
}

COUNT_DF = {
    "group": ["a", "b", "c"],
    "count": [10235, 325, 6426],
    "total": [15590, 498, 15593],
    "proportion": [0.602555045, 0.019133404, 0.378311551],
    "prop_total": [0.492093053, 0.015719201, 0.492187747],
}

N_OVERALL = 20000


@pytest.fixture
def df():
    return DataFrame(BASE_DF)[["group", "num", "prop"]]


@pytest.fixture
def count_total_df():
    return DataFrame(COUNT_DF)[["group", "count", "total"]]


@pytest.fixture
def count_df():
    return DataFrame(COUNT_DF)[["group", "count"]]


@pytest.fixture
def prop_total_df():
    return DataFrame(COUNT_DF)[
        ["group", "count", "total", "proportion", "prop_total"]
    ]


@pytest.fixture
def prop_df():
    return DataFrame(COUNT_DF)[["group", "count", "proportion"]]


def formatteddataframe_notebook_display(fdf):
    """Pull the rich output generated by `display`ing the FDF in a notebook.

    Returns (plaintext, html) outputs. HTML output is restricted to the `table`
    element.
    """
    data = get_notebook_rich_output(display, fdf)
    df_str = data.get("text/plain")
    # The notebook may inject additional styling, etc.
    # Pull out the `table` element (allowing for attrs in the opening tag).
    df_html_match = re.search(
        "<table.*</table>", data.get("text/html"), flags=re.DOTALL
    )
    assert df_html_match is not None
    return (df_str, df_html_match.group())


def compare_fdf_string_html(fdf, expected):
    """Test string and HMTL representations of a FormattedDataFrame.

    Compares both against the corresponding representations for an expected DF.

    The FormattedDataFrame is also rendered using both representations in a
    Jupyter notebook context, and the results are compared against the same
    expected versions.

    Note that this assumes the notebook representation will match the expected
    `to_html()` result.
    """
    expected_str = expected.to_string()
    expected_html = expected.to_html()

    assert fdf.to_string() == expected_str
    assert fdf.to_html() == expected_html

    nb_str, nb_html = formatteddataframe_notebook_display(fdf)
    assert nb_str == expected.to_string()
    assert nb_html == expected.to_html()


def compare_formatting(
    observed, expected, comp_func=compare_fdf_string_html, **kwargs
):
    """Test formatting for a DataFrame via FormattedDataFrame.

    This tests both explicit object instantiation as well as the API function.
    Comparisons are made in terms of both the string and HTML representations.

    Generated FDFs and expected DF are passed to the given comparison function,
    which should include `assert` statements as appropriate.

    Additional keywords args are passed to the FDF instantiation.
    """
    fdf_obj = FormattedDataFrame(observed, **kwargs)
    fdf_api = fmt_df(observed, **kwargs)
    comp_func(fdf_obj, expected)
    comp_func(fdf_api, expected)


def compare_formatteddataframe_string_html_explicit(fdf, expected, formatters):
    # Allow for explicit formatters for the observed DF.
    assert fdf.to_string(formatters=formatters) == expected.to_string()
    assert fdf.to_html(formatters=formatters) == expected.to_html()
    # TODO: use notebook output?


def test_default_formatting(df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": ["10,235", "6,426", "325", "-9,453", "-1,362"],
            "prop": [0.02, 0.33, 0.58, 0.70, 0.25],
        }
    )[["group", "num", "prop"]]

    compare_formatting(df, expected)


def test_explicit_formatter_override(df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": ["10235.0", "6426.0", "325.0", "-9453.0", "-1362.0"],
            "prop": ["0.0243", "0.3333", "0.5781", "0.7000", "0.2500"],
        }
    )[["group", "num", "prop"]]

    explicit_fmt = {
        # This should override dynamic detection of "num" as an int column.
        "num": "{: .1f}".format,
        # This should override static formatting of "prop" as a pct column.
        "prop": "{: .4f}".format,
    }

    def compare_fdfs(obs, exp):
        compare_formatteddataframe_string_html_explicit(
            obs, exp, formatters=explicit_fmt
        )

    compare_formatting(
        df, expected, comp_func=compare_fdfs, fmt_percent="prop"
    )


def test_static_formatting(df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": ["10,235", "6,426", "325", "-9,453", "-1,362"],
            "prop": [0.02426, 0.3333333, 0.578135, 0.7, 0.25],
            "numfl": [
                "10,235.00",
                "6,426.00",
                "325.00",
                "-9,453.00",
                "-1,362.00",
            ],
            "amount": [
                "$10,235.00",
                "$6,426.00",
                "$325.00",
                "-$9,453.00",
                "-$1,362.00",
            ],
            "pct": ["2.43%", "33.33%", "57.81%", "70.00%", "25.00%"],
        }
    )[["group", "num", "prop", "numfl", "amount", "pct"]]

    df["numfl"] = df["num"]
    df["amount"] = df["num"]
    df["pct"] = df["prop"]

    compare_formatting(
        df,
        expected,
        # Override automatic int formatting for 'numfl'.
        # This also deactivates float column detection.
        fmt_float="numfl",
        fmt_percent="pct",
        fmt_dollar="amount",
    )


def test_fmt_custom_precision(df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": ["10,235", "6,426", "325", "-9,453", "-1,362"],
            "prop": ["0.0243", "0.3333", "0.5781", "0.7000", "0.2500"],
            "pct": ["2.426%", "33.333%", "57.813%", "70.000%", "25.000%"],
        }
    )[["group", "num", "prop", "pct"]]

    df["pct"] = df["prop"]

    compare_formatting(
        df, expected, fmt_percent="pct", precision={"prop": 4, "pct": 3}
    )


def test_modified_formatteddataframe(df):
    expected = df.copy()
    expected["num"] = expected["num"].apply("{:,}".format)
    expected["prop"] = expected["prop"].apply("{:.2f}".format)

    # Subsetting a FDF.
    fdf = FormattedDataFrame(df)
    assert fdf[["prop"]].to_string() == expected[["prop"]].to_string()
    assert fdf[["prop"]].to_html() == expected[["prop"]].to_html()
    assert fdf[:3].to_string() == expected[:3].to_string()
    assert fdf[:3].to_html() == expected[:3].to_html()

    # Adding a column to a FDF with no static formatting.
    fdf2 = fdf.copy()
    fdf2["prop2"] = fdf2["prop"]
    expected["prop2"] = df["prop"].apply("{:.2f}".format)
    assert fdf2.to_string() == expected.to_string()
    assert fdf2.to_html() == expected.to_html()

    # Adding a column to a FDF with static formatting.
    fdf3 = FormattedDataFrame(df, fmt_percent="prop")
    fdf3["prop2"] = fdf3["prop"]
    expected["prop"] = df["prop"].apply("{:.2%}".format)
    with pytest.warns(UserWarning):
        assert fdf3.to_string() == expected.to_string()
    with pytest.warns(UserWarning):
        assert fdf3.to_html() == expected.to_html()


def test_fmt_args(df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": ["10,235", "6,426", "325", "-9,453", "-1,362"],
            "prop": ["0.02", "0.33", "0.58", "0.70", "0.25"],
            "numfl": [
                "10,235.00",
                "6,426.00",
                "325.00",
                "-9,453.00",
                "-1,362.00",
            ],
            "pct": ["2.43%", "33.33%", "57.81%", "70.00%", "25.00%"],
        }
    )[["group", "num", "prop", "numfl", "pct"]]

    # Formatting params should accept both single strings and list-likes.
    df["numfl"] = df["num"]
    df["pct"] = df["prop"]

    compare_formatting(
        df,
        expected,
        fmt_int="num",
        fmt_float=["numfl", "prop"],
        fmt_percent={"pct"},
        # This should get silently ignored.
        fmt_dollar=4,
    )


def test_fmt_na_handling(df):
    base_df = df
    df = base_df.copy()
    df.loc[1, "num"] = npnan
    df.loc[3, "prop"] = npnan

    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": ["10,235", "NaN", "325", "-9,453", "-1,362"],
            "prop": ["0.02", "0.33", "0.58", "NaN", "0.25"],
        }
    )[["group", "num", "prop"]]

    # Formatting should work as if NaNs were excluded.
    compare_formatting(df, expected)

    expected = DataFrame(
        {
            "group": ["a", "b", "c", "d", "e"],
            "num": [
                "$10,235.00",
                "NaN",
                "$325.00",
                "-$9,453.00",
                "-$1,362.00",
            ],
            "prop": ["2.426%", "33.333%", "57.813%", "NaN", "25.000%"],
        }
    )[["group", "num", "prop"]]

    compare_formatting(
        df,
        expected,
        fmt_percent="prop",
        fmt_dollar="num",
        precision={"prop": 3},
    )


#-- Testing for fmt_count_df --#

# This mainly covers the different ways args can be passed.


@pytest.mark.skip
def test_fmt_count_default(count_df, count_total_df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c"],
            "count": ["10,235", "325", "6,426"],
            "total": ["15,590", "498", "15,593"],
            "proportion": ["60.26%", "1.91%", "37.83%"],
            "prop_total": ["49.21%", "1.57%", "49.22%"],
        }
    )[["group", "count", "total", "proportion", "prop_total"]]

    # Test the default behaviour when no switches are used.
    result = fmt_count_df(count_df)
    assert result.equals(expected[["group", "count", "proportion"]])

    # Multiple count columns.
    result = fmt_count_df(count_total_df, count_col=["count", "total"])
    assert result.equals(expected)


def test_fmt_count_nofmt(count_df, count_total_df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c"],
            "count": [10235, 325, 6426],
            "total": [15590, 498, 15593],
            "proportion": [0.602555045, 0.019133404, 0.378311551],
            "prop_total": [0.492093053, 0.015719201, 0.492187747],
        }
    )[["group", "count", "total", "proportion", "prop_total"]]

    # Test the default behaviour when no switches are used.
    result = fmt_count_df(count_df, fmt=False)
    assert_frame_equal(result, expected[["group", "count", "proportion"]])

    # Multiple count columns.
    result = fmt_count_df(
        count_total_df, count_col=["count", "total"], fmt=False
    )
    assert_frame_equal(result, expected)


@pytest.mark.skip
def test_fmt_count_n_overall(count_df, count_total_df, prop_df, prop_total_df):
    # Default case is covered in test_fmt_count_default().
    # Case when n_overall is a number:
    expected = prop_df.copy()
    expected["proportion"] = expected["count"] / N_OVERALL
    result = fmt_count_df(count_df, n_overall=N_OVERALL, fmt=False)
    assert result.equals(expected)

    # Case when n_overall is a column.
    expected = prop_total_df.copy()
    expected = expected.drop("prop_total", axis="columns")
    expected["proportion"] = expected["count"] / expected["total"]
    result = fmt_count_df(count_total_df, n_overall="total", fmt=False)
    assert result.equals(expected)
    result = fmt_count_df(count_total_df, n_overall=["total"], fmt=False)
    assert result.equals(expected)

    # Case when n_overall is a list.
    expected = prop_total_df.copy()
    expected["prop_total"] = expected["total"] / N_OVERALL
    result = fmt_count_df(
        count_total_df,
        n_overall=[None, N_OVERALL],
        count_col=["count", "total"],
        fmt=False,
    )
    assert result.equals(expected)

    expected = prop_total_df.copy()
    expected["proportion"] = expected["count"] / expected["total"]
    result = fmt_count_df(
        count_total_df,
        n_overall=["total", None],
        count_col=["count", "total"],
        fmt=False,
    )
    assert result.equals(expected)

    # Reversing the count column order should reverse the order in which
    # the proportion columns appear in the result, with the n_overall list
    # elements applied to the count column names in the same order.
    expected = prop_total_df.copy()
    expected["proportion"] = expected["count"] / expected["total"]
    expected["prop_total"] = expected["total"] / N_OVERALL
    expected = expected[
        ["group", "count", "total", "prop_total", "proportion"]
    ]
    result = fmt_count_df(
        count_total_df,
        n_overall=[N_OVERALL, "total"],
        count_col=["total", "count"],
        fmt=False,
    )
    assert result.equals(expected)


@pytest.mark.skip
def test_fmt_count_colnames(count_total_df, prop_total_df):
    result = fmt_count_df(count_total_df, count_col="total", fmt=False)
    expected = prop_total_df[["group", "count", "total", "prop_total"]]
    assert result.equals(expected)
    result = fmt_count_df(count_total_df, count_col=["total"], fmt=False)
    assert result.equals(expected)
    # The order of the proportion columns should follow the order of
    # the count colunms.
    expected = prop_total_df[
        ["group", "count", "total", "prop_total", "proportion"]
    ]
    result = fmt_count_df(
        count_total_df, count_col=["total", "count"], fmt=False
    )
    assert result.equals(expected)


@pytest.mark.skip
def test_fmt_count_naming_schemes(count_df, prop_df):
    # Test automatic detection of count columns by naming scheme
    # and corresponding automatic naming of proportion columns.
    count_df["n"] = count_df["count"]
    count_df["num"] = count_df["count"]
    count_df["n_items"] = count_df["count"]
    count_df["num_items"] = count_df["count"]

    prop_df[["n", "num", "n_items", "num_items"]] = count_df[
        ["n", "num", "n_items", "num_items"]
    ]
    prop_df["p"] = prop_df["proportion"]
    prop_df["prop"] = prop_df["proportion"]
    prop_df["p_items"] = prop_df["proportion"]
    prop_df["prop_items"] = prop_df["proportion"]
    prop_df = prop_df[
        [
            "group",
            "count",
            "n",
            "num",
            "n_items",
            "num_items",
            "proportion",
            "p",
            "prop",
            "p_items",
            "prop_items",
        ]
    ]

    result = fmt_count_df(count_df, fmt=False)
    assert result.equals(prop_df)


@pytest.mark.skip
def test_fmt_count_col_sort(count_df, count_total_df, prop_df, prop_total_df):
    # Test sorting by count column.
    prop_df = prop_df.sort_values("count", ascending=False)
    result = fmt_count_df(count_df, order_by_count=True, fmt=False)
    assert result.equals(prop_df)
    result = fmt_count_df(count_df, order_by_count="count", fmt=False)
    assert result.equals(prop_df)
    result = fmt_count_df(count_df, order_by_count=["count"], fmt=False)
    assert result.equals(prop_df)

    prop_total_df = prop_total_df.sort_values(
        ["total", "count"], ascending=False
    )
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        order_by_count=["total", "count"],
        fmt=False,
    )
    assert result.equals(prop_total_df)
    # Sorting should use the first count column when unspecified.
    expected = prop_total_df[
        ["group", "count", "total", "prop_total", "proportion"]
    ]
    result = fmt_count_df(
        count_total_df,
        count_col=["total", "count"],
        order_by_count=True,
        fmt=False,
    )
    assert result.equals(expected)


@pytest.mark.skip
def test_fmt_count_cum_pct(count_df, count_total_df, prop_df, prop_total_df):
    # Test appending cumulative percentages.
    prop_df["cum proportion"] = prop_df["proportion"].cumsum()
    result = fmt_count_df(count_df, show_cum_pct=True, fmt=False)
    assert result.equals(prop_df)
    result = fmt_count_df(count_df, show_cum_pct="count", fmt=False)
    assert result.equals(prop_df)
    result = fmt_count_df(count_df, show_cum_pct=["count"], fmt=False)
    assert result.equals(prop_df)

    prop_total_df["cum proportion"] = prop_total_df["proportion"].cumsum()
    prop_total_df["cum prop_total"] = prop_total_df["prop_total"].cumsum()
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        show_cum_pct=True,
        fmt=False,
    )
    assert result.equals(prop_total_df)
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        show_cum_pct=["count", "total"],
        fmt=False,
    )
    assert result.equals(prop_total_df)
    # Ordering of the cumulative proportion columns follows
    # count column ordering.
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        show_cum_pct=["total", "count"],
        fmt=False,
    )
    assert result.equals(prop_total_df)
    # Cumulative prop for a single count column only.
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        show_cum_pct="total",
        fmt=False,
    )
    assert result.equals(prop_total_df.drop("cum proportion", axis="columns"))


def test_fmt_count_pct_colnames(count_df, count_total_df):
    expected_df = DataFrame(
        {
            "group": ["a", "b", "c"],
            "count": ["10,235", "325", "6,426"],
            "total": ["15,590", "498", "15,593"],
            "thepct": ["60.26%", "1.91%", "37.83%"],
            "prop_total": ["49.21%", "1.57%", "49.22%"],
        }
    )[["group", "count", "total", "thepct", "prop_total"]]

    # Test supplying custom names for the percent columns.
    expected = expected_df[["group", "count", "thepct"]]
    result = fmt_count_df(count_df, pct_col_name="thepct")
    compare_fdf_string_html(result, expected)
    result = fmt_count_df(count_df, pct_col_name=["thepct"])
    compare_fdf_string_html(result, expected)

    # When there are multiple count columns
    expected = expected_df
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        pct_col_name=["thepct", None],
    )
    compare_fdf_string_html(result, expected)

    expected = expected_df.rename(columns={"prop_total": "totpct"})
    result = fmt_count_df(
        count_total_df,
        count_col=["count", "total"],
        pct_col_name=["thepct", "totpct"],
    )
    compare_fdf_string_html(result, expected)


def test_fmt_count_fmt_precision(count_df):
    expected = DataFrame(
        {
            "group": ["a", "b", "c"],
            "count": ["10,235", "325", "6,426"],
            "proportion": ["60.26%", "1.91%", "37.83%"],
        }
    )[["group", "count", "proportion"]]

    # Test the conversion to FormattedDataFrame.
    result = fmt_count_df(count_df)
    compare_fdf_string_html(result, expected)

    # Custom precision for percent columns.
    expected["proportion"] = ["60.2555%", "1.9133%", "37.8312%"]
    result = fmt_count_df(count_df, pct_precision=4)
    compare_fdf_string_html(result, expected)
